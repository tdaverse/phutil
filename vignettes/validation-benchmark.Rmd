---
title: "Validation and Benchmark of Wasserstein Distances"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Validation and Benchmark of Wasserstein Distances}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{tdaunif,bench,ggplot2}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette introduces the Wasserstein and bottleneck distances between persistence diagrams and their implementations in {phutil}, adapted from Hera,[^hera] by way of two tasks:

1. Validate the implementations on an example computed by hand.
2. Benchmark the implementations against those provided by {TDA} (adapted from Dionysus).

[^hera]: <https://github.com/anigmetov/hera>

```{r setup}
library(TDA)
library(phutil)
```

We will also use the {tdaunif} package to generate larger point clouds and the {bench} package to perform benchmark tests.

## Definitions

_Persistence diagrams_ are multisets (sets with multiplicity) of points in the plane that encode the interval decompositions of persistent modules obtained from filtrations of data (e.g. Vietoris--Rips filtrations of point clouds and cubical filtrations of numerical arrays).
Most applications consider only ordinary persistent homology, so that all points live in the upper-half plane; and most involve non-negative-valued filtrations, so that all points live in the first quadrant. The examples in this vignette will be no exceptions.

We'll distinguish between persistence diagrams, which encode persistent homology of a single degree, and _persistence data_, which comprises persistent pairs of many degrees (and annotated as such). Whereas a diagram is typically represented as a 2-column matrix with columns for birth and death values, data are typically represented as a 3-column matrix with an additional column for (whole number) degrees.

The most common distance metrics between persistence diagrams exploit the family of _Minkowski distances_ $D_p$ between points in $\mathbb{R}^n$ defined, for $1 \leq p < \infty$, as follows:
$$D_p(x,y) = \left(\sum_{i=1}^{n}{(x_i - y_i)^p}\right)^{1/p}$$
In the limit $p \to \infty$, this expression approaches the following auxiliary definition:
$$D_\infty(x,y) = \max_{i=1}^{n}{\lvert x_i - y_i \rvert}$$
As the parameter $p$ ranges between $1$ and $\infty$, three of its values yield familiar distance metrics: The taxicab distance $D_1$, the Pythagorean distance $D_2$, and the Chebyshev distance $D_\infty$.

The _Kantorovich_ or _Wasserstein metric_[^wasserstein] derives from the problem of optimal transport: What is the minimum cost of relocating one distribution to another?[^kantorovich]
In the space of persistence diagrams, only finitely many points lie off the diagonal, though every point on the diagonal is taken to be included with multiplicity $\mathbb{N}$.
So the cost of relocating one diagram $X$ to another $Y$ amounts to (a) the cost of relocating some off-diagonal points to other off-diagonal points plus (b) the cost of relocating the remaining off-diagonal points to the diagonal (and vice-versa).

[^wasserstein]: <https://en.wikipedia.org/wiki/Wasserstein_metric>
[^kantorovich]: TODO: With time, this more appropriate attribution may become more common. I'd like to at least provide an alias function `kantorovich_distance()` to help that process along.

This cost then depends entirely on how the off-diagonal points are matched, where a _matching_ is any bijective map $\varphi : X \to Y$, though in practice we assume that almost all diagonal points are matched to themselves and incur no cost.
The cost $D(x,\varphi(x))$ of relocating a point $x$ to its matched point $\varphi(x)$ is typically taken to be a Minkowski distance $D_q(x,\varphi(x)) = \lVert x - \varphi(x) \rVert_q$, while the total cost of the relocation is taken to be the $\ell_p$ norm $\lVert ( D(x,\varphi(x)) )_{x \in X} \rVert_p$ of the vector of matched-point distances.
This yields the formulae
$$W_{q,p}(X,Y) = \inf_{\varphi : X \to Y}{\left( \sum_{x \in X}{{\lVert x-\varphi(x) \rVert_q}^p} \right)^{1/p}}$$
for $p < \infty$ and
$$W_{q,\infty}(X,Y) = \inf_{\varphi : X \to Y}{\max_{x \in X}{\lVert x-\varphi(x) \rVert_q}}$$
for $p = \infty$.[^indexing]

[^indexing]: What is the preferred notation for this two-parameter family? Wikipedia uses $W_p[L_q](X,Y)$, but i have not seen that in the literature (yet).

## Validation

### Distances between nontrivial diagrams

The following persistence diagrams provide a tractable example:
$$X = \left[ \begin{array}{cc} 1 & 3 \\ 3 & 5 \end{array} \right]
\phantom{X = Y}
Y = \left[ \begin{array}{cc} 3 & 4 \end{array} \right]$$
For convenience in the code, we omit dimensionality and focus only on the matrix representations.

```{r define small PDs}
X <- rbind(
  c(1, 3),
  c(3, 5)
)
Y <- rbind(
  c(3, 4)
)
```

We overlay both diagrams in Figure \ref{fig:small}.
Note that the vector between the off-diagonal points $(1,3)$ of $X$ and $(3,4)$ of $Y$ is $(2,1)$, while the vector from $(1,3)$ to its nearest diagonal point $(2,2)$ is $(1,-1)$.
That one coordinate is the same size while the other is smaller implies that an optimal matching will always match $(1,3)$ with the diagonal, so long as $p \geq 1$.
A similar argument necessitates that $(3,4)$ of $Y$ must match with $(3,5)$ of $X$.

```{r plot small PDs, fig.width=4, fig.height=4, fig.align='center'}
#| fig.cap=
#| "\\label{fig:small}
#|  Overlaid persistence diagrams $X$ (circles) and $Y$ (diamond)
#|  with dashed segments connecting optimally matched pairs."
par(mar = c(4, 4, 1, 1) + .1)
plot(
  NA_real_,
  xlim = c(0, 6), ylim = c(0, 6), asp = 1, xlab = "birth", ylab = "death"
)
abline(a = 0, b = 1)
points(X, pch = 1)
points(Y, pch = 5)
segments(X[, 1], X[, 2], c(2, Y[, 1]), c(2, Y[, 2]), lty = 2)
par(mar = c(5, 4, 4, 2) + .1)
```

Based on these observations, we get this expression for the Wasserstein distance using the $q$-norm half-plane metric and the $p$-norm "matched space" metric:
$$W_{q,p}(X,Y) = ( {\lVert a \rVert_q}^p + {\lVert b \rVert_q}^p )^{1/p}$$
where $a = (1,-1)$ and $b = (0,-1)$ are the vectors between matched points.
We can now calculate Wasserstein distances "by hand"; we'll consider those using the half-plane Minkowski metrics with $q=1,2,\infty$ and the "matched space" metrics with $p=1,2,\infty$.

First, with $q=1$, we get $\lVert a \rVert_q = 1+1=2$ and $\lVert b \rVert_q = 0+1=1$. So the $1,p$-Wasserstein distance will be the $p$-Minkowski norm of the vector $(2,1)$, given by $W_{1,p}(X,Y) = (2^p + 1^p)^{1/p}$. This nets us the values $W_{1,1}(X,Y) = 3$ and $W_{1,2}(X,Y) = \sqrt{5}$. And then $W_{1,\infty}(X,Y) = \max(2,1) = 2$.
The reader is invited to complete the rest of Table \ref{tab:small}.

```{=latex}
\begin{table}[h]
\centering
\begin{tabular}{ c | c c | c c c }
               & $\lVert a \rVert$ & $\lVert b-x \rVert$ &
         $W_1$ &      $W_2$        &  $W_\infty$         \\
\hline
$\ell_1$       &        $2$        &         $1$         &
           $3$ & $\sqrt{5}$        &         $2$         \\
$\ell_2$       & $\sqrt{2}$        &         $1$         &
$1 + \sqrt{2}$ & $\sqrt{3}$        &  $\sqrt{2}$         \\
$\ell_\infty$  &        $1$        &         $1$         &
           $2$ & $\sqrt{2}$        &         $1$         \\
\end{tabular}
\caption{\label{tab:small}Distances between optimally paired features and Wasserstein distances between $X$ and $Y$ for several choices of half-plane and ``matched space'' metrics.}
\end{table}
```

The results make intuitive sense; for example, the values change monotonically along each row and column.
Let us now validate the bottom row---using the $\ell_\infty$ distance on the half-plane, giving the popular _bottleneck distance_---using both Hela, as exposed through {phutil}, and Dionysus, as exposed through {TDA}:

```{r validate small PDs with Hera}
# TODO: Change default to `tol = 1e-8`.
wasserstein_distance(X, Y, p = 1, tol = 1e-8)
wasserstein_distance(X, Y, p = 2, tol = 1e-8)
bottleneck_distance(X, Y, tol = 1e-8)
```

In order to compute distances with {TDA}, we must restructure the PDs to include a `"dimension"` column.
Note also that `TDA::wasserstein()` does not take the $1/p$th power after computing the sum of $p$th powers; we do this manually to get consistent results:

```{r validate small PDs with Dionysus}
wasserstein(cbind(0, X), cbind(0, Y), p = 1, dimension = 0)
sqrt(wasserstein(cbind(0, X), cbind(0, Y), p = 2, dimension = 0))
bottleneck(cbind(0, X), cbind(0, Y), dimension = 0)
```

### Distances from the trivial diagram

An important edge case is when one persistence diagram is trivial, i.e. contains only the diagonal so is "empty" of off-diagonal points.
This can occur unexpectedly in comparisons of persistence data, as the data may be large but higher-degree features present in one set but absent in another.
To validate the distances in this case, we create an empty diagram $E$ and use the same code to compare it to $X$. The point $(3,5)$ of $X$ will be matched to the diagonal $(4,4)$, which yields the same $\infty$-distance $1$ so the $\ell_\infty$ Wasserstein distances will be the same as before.

```{r validate small PD vs empty}
# empty PD
E <- matrix(NA_real_, nrow = 0, ncol = 2)
# with dimension column
E_ <- cbind(matrix(NA_real_, nrow = 0, ncol = 1), E)
# distance from empty using phutil/Hera
wasserstein_distance(E, X, p = 1, tol = 1e-8)
wasserstein_distance(E, X, p = 2, tol = 1e-8)
bottleneck_distance(E, X, tol = 1e-8)
# distance from empty using TDA/Dionysus
wasserstein(E_, cbind(0, X), p = 1, dimension = 0)
sqrt(wasserstein(E_, cbind(0, X), p = 2, dimension = 0))
bottleneck(E_, cbind(0, X), dimension = 0)
```

**FIXME:** This alternative validation fails.

```{r small PDs with one empty}
Z <- cbind(
  dimension = c(0, 1, 2),
  birth     = c(0, 1, 2),
  death     = c(5, 4, 3)
)
W <- cbind(
  dimension = c(0, 1),
  birth     = c(0, 2),
  death     = c(4, 3)
)
```

...

```{r validate small PDs with one empty}
# TODO: Enable `*_distance()` functions to handle 3-column matrix or data frame,
# perhaps by executing `as_persistence()` internally.
# distance from empty using phutil/Hera
wasserstein_distance(as_persistence(Z), as_persistence(W), p = 1, dimension = 2, tol = 1e-8)
wasserstein_distance(as_persistence(Z), as_persistence(W), p = 2, dimension = 2, tol = 1e-8)
bottleneck_distance(as_persistence(Z), as_persistence(W), dimension = 2, tol = 1e-8)
# distance from empty using TDA/Dionysus
wasserstein(Z, W, p = 1, dimension = 2)
sqrt(wasserstein(Z, W, p = 2, dimension = 2))
bottleneck(Z, W, dimension = 2)
```

...

## Benchmarks

### Distances between small diagrams

**TODO:** Instead of repeating a single calculation, generate random small PDs and benchmark computations on the lot of them?

To illustrate the benchmarking process, and to have a small-scale example against which to compare the large(r)-scale results, we use the first example above.
We define new objects for the `cbind()` operations to prevent them from inflating the {TDA} runtimes.

```{r benchmark phutil and TDA on small PDs}
#| fig.width=6, fig.height=2, fig.align='center',
#| fig.cap=
#| "\\label{fig:benchmark-small}
#|  Benchmark comparison of Dionysus via {TDA} and Hera via {phutil}
#|  on small persistence diagrams:
#|  Violin plots of runtime distributions on a common scale."
X_ <- cbind(0, X); Y_ <- cbind(0, Y)
bm1 <- bench::mark(
  TDA = wasserstein(X_, Y_, dimension = 0, p = 1),
  phutil = wasserstein_distance(X, Y, p = 1, tol = 1e-8)
)
bm2 <- bench::mark(
  TDA = sqrt(wasserstein(X_, Y_, dimension = 0, p = 2)),
  phutil = wasserstein_distance(X, Y, p = 2, tol = 1e-8)
)
bminf <- bench::mark(
  TDA = bottleneck(X_, Y_, dimension = 0),
  phutil = bottleneck_distance(X, Y, tol = 1e-8)
)
bm1$p <- 1; bm2$p <- 2; bminf$p <- Inf
ggplot2::autoplot(rbind(bm1, bm2, bminf), type = "violin") +
  ggplot2::labs(x = NULL, y = NULL)
```

{TDA} clearly outperforms {phutil} on these cases.
Moreover, though both implementations take longer to compute bottleneck distances, {phutil} runtimes are more substantially lengthened.

### Distances between large(r) diagrams



```{r compute large PDs}
# TODO: Indicate where appropriate that vignette depends on R with `|>`.
# this seed ensures that the trefoil sample includes a degree-2 feature
set.seed(28415)
tdaunif::sample_trefoil(n = 120, sd = .05) |> 
  ripsDiag(maxdimension = 2, maxscale = 6) |> 
  as_persistence() -> PD1
tdaunif::sample_arch_spiral(n = 120, arms = 2, sd = .05) |>
  ripsDiag(maxdimension = 2, maxscale = 6) |> 
  as_persistence() -> PD2
```



```{r benchmark phutil and TDA on large PDs}
# TODO: Write `as.matrix()` method for "persistence" class.
# TODO: Write `as_diagram()` function for "persistence" objects.
# FIXME: Ensure that empty PDs are handled correctly.
PD1_ <- as.matrix(as.data.frame(PD1)); PD2_ <- as.matrix(as.data.frame(PD2))
bench::mark(
  TDA = {
    c(
      wasserstein(PD1_, PD2_, dimension = 0, p = 1),
      sqrt(wasserstein(PD1_, PD2_, dimension = 0, p = 2)),
      bottleneck(PD1_, PD2_, dimension = 0),
      wasserstein(PD1_, PD2_, dimension = 1, p = 1),
      sqrt(wasserstein(PD1_, PD2_, dimension = 1, p = 2)),
      bottleneck(PD1_, PD2_, dimension = 1)#,
      # wasserstein(PD1_, PD2_, dimension = 2, p = 1),
      # sqrt(wasserstein(PD1_, PD2_, dimension = 2, p = 2)),
      # bottleneck(PD1_, PD2_, dimension = 2)
    )
  },
  phutil = {
    c(
      wasserstein_distance(PD1, PD2, dimension = 0, p = 1, tol = 1e-8),
      wasserstein_distance(PD1, PD2, dimension = 0, p = 2, tol = 1e-8),
      bottleneck_distance(PD1, PD2, dimension = 0, tol = 1e-8),
      wasserstein_distance(PD1, PD2, dimension = 1, p = 1, tol = 1e-8),
      wasserstein_distance(PD1, PD2, dimension = 1, p = 2, tol = 1e-8),
      bottleneck_distance(PD1, PD2, dimension = 1, tol = 1e-8)#,
      # wasserstein_distance(PD1, PD2, dimension = 2, p = 1, tol = 1e-8),
      # wasserstein_distance(PD1, PD2, dimension = 2, p = 2, tol = 1e-8),
      # bottleneck_distance(PD1, PD2, dimension = 2, tol = 1e-8)
    )
  }
)
```
