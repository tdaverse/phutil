---
title: "Validation and Benchmark of Wasserstein Distances"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Validation and Benchmark of Wasserstein Distances}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{tdaunif,bench}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette introduces the Wasserstein and bottleneck distances between persistence diagrams and their implementations in {phutil}, adapted from Hera,[^hera] by way of two tasks:

1. Validate the implementations on an example computed by hand.
2. Benchmark the implementations against those provided by {TDA} (adapted from Dionysus).

[^hera]: <https://github.com/anigmetov/hera>

```{r setup}
library(TDA)
library(phutil)
```

We will also use the {tdaunif} package to generate larger point clouds and the {bench} package to perform benchmark tests.

## Definitions

_Persistence diagrams_ are multisets (sets with multiplicity) of points in the plane that encode the interval decompositions of persistent modules obtained from filtrations of data (e.g. Vietoris--Rips filtrations of point clouds and sublevel set filtrations of numerical arrays).
Most applications consider only ordinary persistent homology, so that all points like in the upper-half plane; and most involve non-negative-valued filtrations, so that all points like in the first quadrant. The examples in this vignette will be typical in this respect.

We'll distinguish between persistence diagrams, which encode persistent homology of a single degree, and _persistence data_, which comprises persistent pairs of all degrees (with degree labels). Whereas a diagram is typically stored as a 2-column matrix (birth and death values), data are typically stored as a 3-column matrix (with integer degrees).

The most common distance metrics between persistence diagrams exploit the family of _Minkowski distances_ $D_p$ between points in $\mathbb{R}^n$ defined, for $1 \leq p < \infty$, as follows:
$$D_p(x,y) = \left(\sum_{i=1}^{n}{(x_i - y_i)^p}\right)^{1/p}$$
In the limit $p \to \infty$, this expression approaches the following auxiliary definition:
$$D_\infty(x,y) = \max_{i=1}^{n}{\lvert x_i - y_i \rvert}$$
As the parameter $p$ ranges between $1$ and $\infty$, three of its values yield familiar distance metrics: The taxicab distance $D_1$, the Pythagorean distance $D_2$, and the Chebyshev distance $D_\infty$.

The _Kantorovich_ or _Wasserstein metric_[^wasserstein] derives from the problem of optimal transport: What is the minimum cost of relocating one distribution to another?[^kantorovich]
In the space of persistence diagrams, only finitely many points lie off the diagonal, though every point on the diagonal is taken to be included with multiplicity $\mathbb{N}$.
So the cost of relocating one diagram $X$ to another $Y$ amounts to (a) the cost of relocating some off-diagonal points to other off-diagonal points plus (b) the cost of relocating the remaining off-diagonal points to the diagonal (and vice-versa).

[^wasserstein]: <https://en.wikipedia.org/wiki/Wasserstein_metric>
[^kantorovich]: TODO: With time, this more appropriate attribution may become more common. I'd like to at least provide an alias function `kantorovich_distance()` to help that process along.

This cost depends on how the off-diagonal points are matched, where a _matching_ is any bijective map $\varphi : X \to Y$, though in practice we assume that almost all diagonal points are matched to themselves and incur no cost.
The cost of relocating a point $x$ to its matched point $\varphi(x)$ is typically taken to be the Minkowski distance $D_q(x,\varphi(x)) = \lVert x - \varphi(x) \rVert_q$, while the total cost of the relocation is taken to be the Minkowski magnitude $\lVert ( D_q(x,\varphi(x)) )_{x \in X} \rVert_p$ of the vector of these matched-point distances.
For $p < \infty$, this yields the formula:
$$W_{q,p}(X,Y) = \inf_{\varphi : X \to Y}{\left( \sum_{x \in X}{{\lVert x-\varphi(x) \rVert_q}^p} \right)^{1/p}}$$

## Validation

### Distances between nontrivial diagrams

The following persistence diagrams---let's denote them $X$ and $Y$---provide a tractable example.
For convenience, we omit dimensionality and focus only on the matrix representations.

```{r define small PDs}
pd1 <- rbind(
  c(1, 3),
  c(3, 5)
)
pd2 <- rbind(
  c(3, 4)
)
```

We overlay both diagrams in Figure \ref{fig:small}.
Note that the off-diagonal points $(1,3)$ of $X$ and $(3,4)$ of $Y$ form a coordinate right triangle with the diagonal point $(3,3)$. This implies that pairing $(1,3)$ with the diagonal will always obtain an optimal matching, regardless of the norm.[^pythagorean]
Conversely, $(3,4)$ subtends a coordinate right triangle with the other off-diagonal point $(3,5)$ of $X$ and the diagonal point $(4,4)$, which (since $(1,3)$ is unavailable) implies that these two off-diagonal points will always optimally match.

[^pythagorean]: TODO: I think this is true but need to prove it.

```{r plot small PDs, fig.width=4, fig.height=4, fig.align='center'}
#| fig.cap=
#| "\\label{fig:small}
#|  Overlaid persistence diagrams $X$ (circles) and $Y$ (diamond)."
par(mar = c(4, 4, 1, 1) + .1)
plot(
  NA_real_,
  xlim = c(0, 6), ylim = c(0, 6), asp = 1, xlab = "birth", ylab = "death"
)
abline(a = 0, b = 1)
points(pd1, pch = 1)
points(pd2, pch = 5)
par(mar = c(5, 4, 4, 2) + .1)
```

Based on these observations, the Wasserstein distance using the $q$-norm half-plane metric and the $p$-norm "matched space" metric is:
$$W_{q,p}(X,Y) = ( {\lVert a \rVert_q}^p + {\lVert b - x \rVert_q}^p )^{1/p}$$
Using this expression, we will calculate several Wasserstein distances by hand.
We will consider the half-plane Minkowski metrics with $q=1,2,\infty$ and the "matched space" metrics with $p=1,2,\infty$.

First, with $q=1$, we get $\lVert a \rVert_q = 1+1=2$ and $\lVert b - x \rVert_q = 0+1=1$. So the $1,p$-Wasserstein distance will be the $p$-Minkowski norm of the vector $(2,1)$, given by $W_{1,p}(X,Y) = (2^p + 1^p)^{1/p}$. This nets us the values $W_{1,1}(X,Y) = 3$ and $W_{1,2}(X,Y) = \sqrt{5}$. And then $W_{1,\infty}(X,Y) = \max(2,1) = 2$.
The reader is invited to complete the rest of Table \ref{tab:small}.

```{=latex}
\begin{table}[h]
\centering
\begin{tabular}{ c | c c | c c c }
               & $\lVert a \rVert$ & $\lVert b-x \rVert$ &
         $W_1$ &      $W_2$        &  $W_\infty$         \\
\hline
$\ell_1$       &        $2$        &         $1$         &
           $3$ & $\sqrt{5}$        &         $2$         \\
$\ell_2$       & $\sqrt{2}$        &         $1$         &
$1 + \sqrt{2}$ & $\sqrt{3}$        &  $\sqrt{2}$         \\
$\ell_\infty$  &        $1$        &         $1$         &
           $2$ & $\sqrt{2}$        &         $1$         \\
\end{tabular}
\caption{\label{tab:small}Distances between optimally paired features and Wasserstein distances between $X$ and $Y$ for several choices of half-plane and ``matched space'' metrics.}
\end{table}
```

The results make intuitive sense; for example, the values change monotonically along each row and column.
Let us now validate the bottom row---using the $\ell_\infty$ distance on the half-plane---using both Hela (as exposed through {phutil}) and Dionysus (as exposed through {TDA}):

```{r validate small PDs with Hera}
wasserstein_distance(pd1, pd2, p = 1, tol = 1e-8)
wasserstein_distance(pd1, pd2, p = 2, tol = 1e-8)
bottleneck_distance(pd1, pd2, tol = 1e-8)
```

In order to compute distances with {TDA}, we must restructure the PDs to include a `"dimension"` column.
Note also that `TDA::wasserstein()` does not take the $1/p$th power after computing the sum of $p$th powers; we do this manually to more easily compare results:

```{r validate small PDs with Dionysus}
wasserstein(cbind(0, pd1), cbind(0, pd2), p = 1, dimension = 0)
sqrt(wasserstein(cbind(0, pd1), cbind(0, pd2), p = 2, dimension = 0))
bottleneck(cbind(0, pd1), cbind(0, pd2), dimension = 0)
```

### Distances from the trivial diagram

An important edge case for these functions is when one persistence diagram is trivial, i.e. contains only the diagnoal so is "empty" of off-diagonal points.
This can occur unexpectedly in comparisons of persistence data, as the data may be large but higher-degree features present in one set but absent in another.



```{r validate small PD vs empty with Hera}
pd0 <- matrix(NA_real_, nrow = 0, ncol = 2)
wasserstein_distance(pd0, pd1, p = 1, tol = 1e-8)
wasserstein_distance(pd0, pd1, p = 2, tol = 1e-8)
bottleneck_distance(pd0, pd1, tol = 1e-8)
```



```{r validate small PD vs empty with Dionysus}
dpd0 <- cbind(matrix(NA_real_, nrow = 0, ncol = 1), pd0)
wasserstein(dpd0, cbind(0, pd1), p = 1, dimension = 0)
sqrt(wasserstein(dpd0, cbind(0, pd1), p = 2, dimension = 0))
bottleneck(dpd0, cbind(0, pd1), dimension = 0)
```




```{r small PDs with one empty}
pd1 <- cbind(
  dimension = c(0, 1, 2),
  birth     = c(0, 1, 2),
  death     = c(5, 4, 3)
)
pd2 <- cbind(
  dimension = c(0, 1),
  birth     = c(0, 2),
  death     = c(4, 3)
)
```



```{r validate small PDs with one empty with Hera}
# TODO: Enable `*_distance()` functions to handle 3-column matrix or data frame,
# perhaps by executing `as_persistence()` internally.
wasserstein_distance(as_persistence(pd1), as_persistence(pd2), p = 1, dimension = 2, tol = 1e-8)
wasserstein_distance(as_persistence(pd1), as_persistence(pd2), p = 2, dimension = 2, tol = 1e-8)
bottleneck_distance(as_persistence(pd1), as_persistence(pd2), dimension = 2, tol = 1e-8)
```



```{r validate small PDs with one empty with Dionysus}
wasserstein(pd1, pd2, p = 1, dimension = 2)
sqrt(wasserstein(pd1, pd2, p = 2, dimension = 2))
bottleneck(pd1, pd2, dimension = 2)
```

## Benchmarks



```{r benchmark phutil and TDA on small PDs}
pd1 <- rbind(c(1, 3), c(3, 5))
pd2 <- rbind(c(3, 4))
dpd1 <- cbind(0, pd1); dpd2 <- cbind(0, pd2)
bench::mark(
  TDA = {
    c(
      wasserstein(dpd1, dpd2, dimension = 0, p = 1),
      sqrt(wasserstein(dpd1, dpd2, dimension = 0, p = 2)),
      bottleneck(dpd1, dpd2, dimension = 0)
    )
  },
  phutil = {
    c(
      wasserstein_distance(pd1, pd2, p = 1, tol = 1e-8),
      wasserstein_distance(pd1, pd2, p = 2, tol = 1e-8),
      bottleneck_distance(pd1, pd2, tol = 1e-8)
    )
  }
)
```



```{r compute large PDs}
# TODO: Indicate where appropriate that vignette depends on R with `|>`.
# this seed ensures that the trefoil sample includes a degree-2 feature
set.seed(28415)
tdaunif::sample_trefoil(n = 120, sd = .05) |> 
  ripsDiag(maxdimension = 2, maxscale = 6) |> 
  as_persistence() -> pd1
tdaunif::sample_arch_spiral(n = 120, arms = 2, sd = .05) |>
  ripsDiag(maxdimension = 2, maxscale = 6) |> 
  as_persistence() -> pd2
```



```{r benchmark phutil and TDA on large PDs}
# TODO: Write `as.matrix()` method for "persistence" class.
# TODO: Write `as_diagram()` function for "persistence" objects.
# FIXME: Ensure that empty PDs are handled correctly.
dpd1 <- as.matrix(as.data.frame(pd1)); dpd2 <- as.matrix(as.data.frame(pd2))
bench::mark(
  TDA = {
    c(
      wasserstein(dpd1, dpd2, dimension = 0, p = 1),
      sqrt(wasserstein(dpd1, dpd2, dimension = 0, p = 2)),
      bottleneck(dpd1, dpd2, dimension = 0),
      wasserstein(dpd1, dpd2, dimension = 1, p = 1),
      sqrt(wasserstein(dpd1, dpd2, dimension = 1, p = 2)),
      bottleneck(dpd1, dpd2, dimension = 1)#,
      # wasserstein(dpd1, dpd2, dimension = 2, p = 1),
      # sqrt(wasserstein(dpd1, dpd2, dimension = 2, p = 2)),
      # bottleneck(dpd1, dpd2, dimension = 2)
    )
  },
  phutil = {
    c(
      wasserstein_distance(pd1, pd2, dimension = 0, p = 1, tol = 1e-8),
      wasserstein_distance(pd1, pd2, dimension = 0, p = 2, tol = 1e-8),
      bottleneck_distance(pd1, pd2, dimension = 0, tol = 1e-8),
      wasserstein_distance(pd1, pd2, dimension = 1, p = 1, tol = 1e-8),
      wasserstein_distance(pd1, pd2, dimension = 1, p = 2, tol = 1e-8),
      bottleneck_distance(pd1, pd2, dimension = 1, tol = 1e-8)#,
      # wasserstein_distance(pd1, pd2, dimension = 2, p = 1, tol = 1e-8),
      # wasserstein_distance(pd1, pd2, dimension = 2, p = 2, tol = 1e-8),
      # bottleneck_distance(pd1, pd2, dimension = 2, tol = 1e-8)
    )
  }
)
```
